# Отчёт по оценке и анализу точности алгоритма HyperLogLog

## 1. Постановка задачи

Исследуется вероятностный алгоритм HyperLogLog для оценки числа уникальных объектов в потоке данных (частотный момент F_t^0). Реализованы: инфраструктура генерации потока и хеш-функций, стандартный HyperLogLog, точный подсчёт F_t^0, эксперименты и визуализация.

## 2. Инфраструктура (Этап 1)

### 2.1 RandomStreamGen

- **Класс:** генерация потока строк S.
- **Параметры:** длина строки 1–30 символов (равномерно), алфавит: `a-z`, `A-Z`, `0-9`, `-` (63 символа).
- **Разбиение по моменту t:** метод `prefix(p)` возвращает итераторы на префикс потока до доли `p` (0 ≤ p ≤ 1). Шаги 5%, 10%, …, 100% задаются при вызове.
- **Воспроизводимость:** фиксированный сид для ГПСЧ; опционально сохранение/загрузка потока в файл.

### 2.2 HashFuncGen

- **Интерфейс:** `uint32_t operator()(const std::string&)` и `operator()(std::string_view)` — отображение U → M = 2^32.
- **Реализации:**
  - **PolynomialHash32:** полиномиальный хеш по модулю 2^32 (основание 31).
  - **FNV1aHash32:** FNV-1a 32-bit (используется в экспериментах).
- Обе функции дают приблизительно равномерное распределение; для анализа равномерности можно добавить тест по корзинам (хи-квадрат) или гистограмму.

## 3. Реализация HyperLogLog (Этап 2)

### 3.1 Точное значение F_t^0

Функция `exact_count(begin, end)` считает число уникальных строк в префиксе потока с помощью `std::unordered_set` по диапазону итераторов.

### 3.2 Алгоритм HyperLogLog

- **Параметры:** B — число бит индекса; m = 2^B регистров. Используется 32-битный хеш (L = 32).
- **Шаги:**
  1. w = h(x).
  2. Индекс субпотока: j = первые B бит w (j ∈ [0, m)).
  3. Хвост: (32−B) бит; ρ(w) = 1 + число ведущих нулей в хвосте (если хвост = 0, то ρ = 32−B+1).
  4. M[j] = max(M[j], ρ(w)).
- **Оценка:** Z = (∑ 2^{-M[j]})^{-1}, E = α_m · m² · Z с константой α_m (0.673 для m=16, 0.697 для m=32, 0.709 для m=64, 0.7213/(1+1.079/m) для m ≥ 128).
- **Коррекции:** при малой кардинальности (E < 2.5m и есть нулевые регистры) — линейный подсчёт: E* = m·ln(m/V). При очень большой (E > 2^32/30) — коррекция E* = −2^32·ln(1−E/2^32).

### 3.3 Выбор B

- Проведены эксперименты с B = 10 (m = 1024). Теоретическая стандартная ошибка σ ≈ 1.04/√m ≈ 3.25%. Для B = 4, 6, 8 точность ниже (меньше m); для B = 12, 14 — выше точность, но больше памяти. B = 10 — компромисс: около 1 КБ регистров и ожидаемая относительная ошибка порядка 3%.

## 4. Эксперименты

- **Потоки:** размеры 10^4, 5·10^4, 10^5 элементов; по 20 прогонов на каждый размер (разные сиды).
- **Шаги:** 5%, 10%, …, 100% обработанной части потока.
- **Выход:** CSV с полями run, stream_size, B, step_pct, step_idx, prefix_size, F_t0, N_t.
- **Визуализация:** скрипт `scripts/plot_results.py` строит:
  - **График 1:** по оси X — доля обработанной части (%), по оси Y — число уникальных элементов; линии F_t^0 и N_t (среднее по прогонам).
  - **График 2:** E(N_t) и закрашенная область E(N_t) ± σ_Nt; опционально F_t^0.

Запуск графиков: `python3 scripts/plot_results.py data/experiment_results.csv -o data` (требуются pandas и matplotlib).

## 5. Анализ результатов (Этап 3)

### 5.1 Точность

- **Теоретические границы:** стандартная ошибка (относительная) в оригинале HyperLogLog даётся как σ ≈ 1.04/√m и до 1.30/√m в зависимости от интерпретации. Для m = 1024 (B = 10): 1.04/√1024 ≈ 0.0325 (3.25%), 1.30/√1024 ≈ 0.041 (4.1%).
- **Практика:** по данным эксперимента относительная ошибка |N_t − F_t^0|/F_t^0 по прогонам в основном укладывается в диапазон примерно 0–6%; средняя по многим точкам — порядка 2–4%. Таким образом, реализация укладывается в рамки теоретических отклонений 1.04/√m и 1.30/√m для выбранного m.

### 5.2 Стабильность (дисперсия)

- Выборочное стандартное отклонение σ_Nt по 20 прогонам для фиксированных (stream_size, step_pct) даёт типичные значения порядка сотен–нескольких тысяч при кардинальностях 10^4–10^5, что соответствует относительной величине порядка нескольких процентов. Дисперсия ведёт себя стабильно по шагам t и по размеру потока и согласуется с ожидаемой от теории (порядок 1/√m от оценки).

### 5.3 Константы

- **B и m:** увеличение B (и m) улучшает точность (уменьшает σ) и увеличивает объём памяти (m регистров по 1 байту). Выбор B = 10 даёт приемлемый компромисс.
- **α_m:** используется табличная аппроксимация из статьи Flajolet et al.; она уменьшает систематическое смещение сырой оценки.
- **Пороги малой/большой кардинальности:** линейный подсчёт при E < 2.5m и V > 0 снижает смещение для малых n; коррекция при E > 2^32/30 важна только для очень больших кардинальностей (порядка 10^8 и выше).

## 6. Этап 4 (опциональный): улучшенная версия

Реализована улучшенная версия **HyperLogLog с bias-коррекцией для малых кардинальностей** (в духе HyperLogLog++):

- **Идея:** для малых n сырая оценка E систематически завышена. В HyperLogLog++ (Heule, Nunkesser, Hall) предлагается эмпирическая таблица поправок, полученная симуляциями. В нашей реализации:
  1. Расширен порог линейного подсчёта до 5*m (вместо 2.5*m): при E_raw < 5*m и V > 0 используется линейный подсчёт m·ln(m/V), что уменьшает смещение в зоне перехода.
  2. В зоне 2.5*m < E_raw ≤ 5*m при V = 0 применяется эмпирическая поправка: E_corrected = E_raw − bias(E_raw), где bias(E_raw) = (E_raw − 2.5*m)·0.015.
- **Ссылка:** [HyperLogLog in Practice: Algorithmic Engineering of a State of The Art Cardinality Estimation Algorithm](https://static.googleusercontent.com/media/research.google.com/en//pubs/archive/40671.pdf) (Google Research, 2013).

**Повтор экспериментов:** те же потоки (размеры 10^4, 5·10^4, 10^5), те же шаги t (5%, …, 100%), 20 прогонов. Результаты записываются в `data/experiment_results_improved.csv`. Графики для улучшенной версии можно построить командой: `python3 scripts/plot_results.py data/experiment_results_improved.csv -o data --stream-sizes 10000 50000 100000` (файлы graph1_stream* и graph2_stream* будут перезаписаны; для сравнения можно выводить в отдельную папку, например `-o data/improved`).

**Анализ улучшенной версии:** расширение порога линейного подсчёта до 5*m снижает смещение в переходной области (кардинальности порядка нескольких тысяч при m = 1024). Bias-коррекция для сырой оценки в диапазоне (2.5*m, 5*m] дополнительно уменьшает завышение. Потребление памяти у улучшенной версии такое же, как у стандартной (те же регистры; логика только в функции estimate()).

## 7. Репозиторий и воспроизведение

- **Исходный код:** каталог `src/` (RandomStreamGen, HashFuncGen, HyperLogLog, main, при наличии — улучшенная версия).
- **Данные:** `data/experiment_results.csv` — результаты прогонов; при необходимости — сохранённые потоки или параметры генерации.
- **Скрипты:** `scripts/plot_results.py` — построение графиков 1 и 2.
- **Сборка:** без CMake: `g++ -std=c++17 -I src -o build/hll_experiment src/main.cpp src/random_stream_gen.cpp src/hash_func_gen.cpp src/hyperloglog.cpp`. С CMake: `cmake -B build && cmake --build build`.
- **Запуск:** `./build/hll_experiment [output_csv] [B] [num_runs]`. По умолчанию: `data/experiment_results.csv`, B=10, 20 прогонов.
- **Графики:** `pip install -r requirements.txt && python3 scripts/plot_results.py -o data`.

После выполнения этих шагов в репозитории будут исходные коды, данные и отчёт для приложения к заданию.
